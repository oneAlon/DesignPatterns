//
//  ViewController.swift
//  3工厂方法模式
//
//  Created by xygj on 2018/11/13.
//  Copyright © 2018 xygj. All rights reserved.
//

import UIKit

/*
 需求:
    Sunny软件公司欲基于Java语言开发一套图表库，该图表库可以为应用系统提供各种不同外观的图表，例如柱状图、饼状图、折线图等。
    有时候图表的初始化参数的设置过程较为复杂，而且某些参数的设置有严格的先后次序，否则可能会显示错误。
    如何封装图表的初始化过程并保证多种图表切换的灵活性是Sunny公司开发人员面临的一个难题。
 
 
 方案分析:
 1.原始方案(简单工厂方案)
     通过使用简单工厂模式，我们将图表对象的创建和使用分离，客户端只需使用由工厂类创建的图表对象即可，无须关心对象的创建过程,
     但是我们发现，虽然简单工厂模式实现了对象的创建和使用分离，但是仍然存在如下两个问题：
        (1) 工厂类过于庞大，包含了大量的if…else…代码，导致维护和测试难度增大；
        (2) 系统扩展不灵活，如果增加新类型的日志记录器，必须修改静态工厂方法的业务逻辑，违反了“开闭原则”。
        (3) 初始化过程相关设置复杂,造成构造函数庞大
 
 2.工厂方法模式
     在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，
     所以,提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象。
     在实际使用时，具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作
 
 
 使用场景:
    1.客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，
      具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中
    2.抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，
      而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。
 */

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        
        // 客户端只需要关心工厂类就可以, 不同的具体工厂创建不同的产品, 返回的类型是YANewChartProtocol
        let chart = YANewPieFactory.createChart()
        chart.display()
        
        // 如果需要新增图表, 只需要创建一个具体图表的工厂类, 不需要修改抽象工厂的源码
        let lineChart = YANewLineFactory.createChart()
        lineChart.display()
        
        
        // 隐藏工厂方法
        YANewPieFactory.displayChart()
    }


}

